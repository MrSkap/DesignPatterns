Проект с примерами паттернов проектирования

## Поведенческие паттерны

### Стратегия (Strategy)

Пример стратегии - IFiller и его наследники и StorageService, который, через передаваемый ему контекст и фабричный
метод, получает нужного ему наследника и заполняет хранилища нужным образом.

Паттерн позволяет инкапслуровать поведение и подменять его при необходимости.

В данном примере, StorageService не знает как именно выполнялось заполнение хранилищ, он получил нужный объект и вызвал
метод, делающий то, что ему нужно.

Еще пример стратегии можно встретить при распределении зависимостей в DI. При конфигурации сервисов можно указать
необходимые реализации для конкретных классов, таким образом можно изменять стандартную реализацию или указывать
специфическую.

В .NET стратегии применяются повсеместно, так например в LINQ с помощью лямб передаются указания, как именно нужно
сравнивать элементы. Можно это сделать реализовав интерфейс IComparer.

### Шаблонный метод (Template method)

Три различных варианта реализации паттерна Шаблоный метод: классический через абстрактный класс и наследников, через
делегаты, через расширения.
DesignPatterns/Application/Strategy.

Паттерн нужен для получения возможности изменения некоторых этапов алгоритма, без изменения структы алгоритма в целом.

Шаблонный метод следует использовать там, где появилась необходимость переиспользовать код с частичными изменениями.

Шаблонный метод можно встретить например в IDisposable.

### Посредник (Mediator)

Нужен для объединения классов, при этом давая им возможность развиваться независимо.
DesignPatterns/Application/Mediator

StoragePacker - класс, связывающий IGoodsProvider и IStorageProvider.

Не стоит использовать посредника в сильно связанных классах, это может усложнить понимание работы классов и вместо
изменений в двух классах, придется вносить изменения во все 3.

Посредники применяются очень часто, важно не усложнять ими дальнейшую разработку а наоборот упрощать дальнейшее развитие
систем.

Посредники применяются в взаимодействии между целыми модулями и слоями. Так уровень приложения (application) часто может
являться посредником между доменным (domain) и сервисными уровнями (service).

### Итератор (Iterator)

Паттерн предоставляет доступ ко всем элементам составного объекта (коллекции), не раскрывая его внутреннего содержания (
не предоставляя всю коллекцию, только отдельные элементы).
Паттерн нужен для оптимизации работы с коллекциями, ограничения доступа к ним и предаставления ограниченного API для
работы с ними.

В .NET есть готовая к использованию реализация этого паттерна IEnumerator и IEnumerable

Для работы с foreach необязательно наследоваться от IEnumerable<T> \ IEnumerator.
Достаточно, чтобы класс коллекции содержал метод GetEnumerator, который будет возвращать тип с методом bool MoveNext() и
свойством
Current.

Паттерн итератор можно использовать для создания генераторов. Для генерации значений, а не для обхода внутренней
коллекции.

Существует две возможные реализации итераторов: внешние и внутренние. Внешние - обход производится клиентом, путем
вызова Next(). Внутренний итератор информирует
клиентов о том, что текущий элемент переключен или вызывает самостоятельно метод, который ему передает клиент при
появлении нового (слудующего) эелемента.

IEnumerable \ IEnumerator - пример внешнийх итераторов. GoodsIterator, GoodsCreator
IObserver \ IObservable - пример внутреннего итератора. ObservableGoods и GoodsObserver.

Использовать стоит для оптимизации, если объекты в коллекции будут обрабатываться разово (например для чтения
использутся один foreach), то итераторы топ!
Возможны случаи, когда есть есть необходимость оградить существующую коллекцию и предоставлять к ней закрытый доступ.

<h3>Наблюдатель (Observer)</h3>
Наблюдатель позволяет уведомить всех желающих об изменении состояния или событии.

В .net есть несколько способов реализации этого паттерна:

* интерфейсы-наблюдатели (см. классическую диаграму паттерна)
* события
* делегаты
* интерфейсы IObserver/IObservable

#### Когда и что использовать

Реализация через стандартную схему можно использовать при наличии каких-либо внутренних абстракций.
Релизация через делегаты удобна при соотношении 1 к 1. Однако нужно быть увереным, что в дальнейшем получателей не
станет несколько.
Реализация через события удобна в большинстве других случаев, однако нужно внимательно следить за получателями, так как
есть риск утечки памяти при пропаже получателей. Для борьбы с утечками можно использовать слабыми событиями Weak Event
Pattern
Реализация через IObservable может быть чуть более грамоздкой и сложно (по моему мнению), однако несет в себе куда
меньше рисков утечки, позволяет очень гибко настраивать обработку новых сообщений.

Ситуации для применения паттерна:

1. Отслеживание состояния объектов, находящихся вне приложения (файлов, программ)
2. Интервальное появление новых данных (раз в n минут нужно что-то делать)
3. В MVC часто используется данный паттерн для свзывания модели и контроллера
4. В целом позволяет связать разные части приложения воедино

### Посетитель (Visitor)

Паттерн позволяет добавить новую функциональность практически не изменяя классы.

Паттерн следует использовать в ситуациях, когда набор типов стабилен, но операции в этих типах нет.
Функиональный вариант лучше подойдет в небольших иерархичных структурах, затем можно будет вернуться и передалать через
классический вариант реализации данного паттерна.

### Команда (Command)

Паттерн позволяет оборачивать запросы в объекты, вызывать их когда нужно, а также сохранять состояние или составлять
последовательность исполненных команд.
В .net удоблее успользовать реализацию через делегаты, так больше гибкости и возможности переиспользования.

Примером в .net можно назвать Task<T>, объект принимает делегат Funk<T> который может быть вызван в будущем для
получения результата задачи.

Когда можно задуматься об использовании паттерна:

* Необходимо хранить историю вызовов
* Отмена операций
* Очередь запросов
* Отложенный вызов
* Передача команд другим объектам

### Состояние (State)

Позволет изменять объекту изменять свое поведение в зависимости от внутреннего состояния.

Если есть задача полностью ограничить использование некторых методов, состояния могут реализовывать различный набор
интерфейсов и подходить под разные ситуации.

В .net Task изменяет свое состояние в течении создания, выполнения и завершения выполнения задачи.

Не стоит использовать, если этих состояний не много и их логика не так сложна.

Стоит использовать:

* Когда есть потребность в изменении логики работы объекта в зависимости от каких-либо внутренних изменений

## Порождающие паттерны

### Одиночка (Singleton)

Гарантирует, что у класса есть только один экземпляр, предоставляет единую точку доступа к нему.

В .net при реализации главное учитывать два пункта:

* Аддекватная работа в многопоточном приложении
* Возможность ленивой иницианализации

Через DI создать синглтон довольно просто:

```
// services - IServiceCollection
services.AddSingleton<ISingletonInterface, SomeSingleton>();
```

Объявление сразу закроет вопрос ленивости создания, так как объект создастся только при первой необходимости в нем.
Вопрос многопоточности уже зависит от реализации самого класса.

Чего лучше избегать при работе с singleton классами:

* Избегать изменчивости состояния объекта - если доступный всем класс начнет вести себя по-другому, это может повлечь за
  собой большое количество ошибок
* Избегать большого количества зависимостей у синглтона - если такое заметно, то ошибка носит системный характер и
  возможно нужен рефакторинг
* Избегать цепочки вызовов синглтонов - если такое заметно, то ошибка носит системный характер и возможно нужен
  рефакторинг

На что стоит обратить внимание:

* Стоит выделять интерфейсы синглтона и предоставлять доступ к нему через них, лишний раз лучше не давать возможность
  каким-либо образом влиять на него извне
* Помнить о возможности порождения дочерних классов от синглтона, возможно наследник может лучше подойти к конкретной
  ситуации в приложении
* При хранении различных хешей стоит использовать потокобезопасные типы данных, или позволять обращаться к ним используя
  атомарные операции или блокировки

Когда использовать:

* Для хранения и предоставления различных конфигов и хешей
* Для обособленных внешних задач, где не может быть больше одного объекта, который этим будет заниматься - напр. следить
  за состоянием бд и вызывать бекапы или свертки данных (compact в mongodb)
* Мониторинг файлов (конфигов) и оповещение об их изменении

Также придется использовать, когда уже есть цепочка синглтонов и нужно будет прокинуть связь с кем-то из них (Но
возможно, это нужно все переделывать!)

Личное мнение по паттерну:

Кто-бы что не говорил, но не могу назвать синглтон антипаттерном, так как ситуаций, где без него не обойтись, довольно
много. Также синглтон может позволить, возможно, ценой ухудшения архитектуры и тестируемости, улучшить
производительность (за счет хеширования данных).
У паттерна много тонкостей и применять его нужно осторожно, но при правильном использовании можно получить множество
плюсов и упростить себе жизнь, при проектировании.

### Абстрактая фабрика (Abstract factory)

Астрактая фабрика предоставляет интерфейс для создания семейства взаимосвязанных или родственных объектов. По сути это
стратегия для создания объеков.

Как и следующий паттерн, фабричный метод, нужна абстрактаня фабрика в общем счете нужна для инкапсуляции создания
объектов.

Когда использовать:

Как минимум, нужно учитывать, что для абстрактной фабрики нужны две вещи: семейство обхектов для создания и возможность
замены этих объектов во время исполнения.
Это наличие дает повод подумать об использовании абстрактной фабрики.
Но использовать нужно, когда, действительно, семейство объектов обширно, работа с ними может быть разообразна и создание
этих объектов нецентрализованно несет в себе хаос.

Абстрактная фабрика может сильно усложнить систему, поэтому лучше ее применять, когда она действительно нужна, что может
произойти не в начале проектирования и разработки системы.
Однако помимо сложности она приносит и гибкость, именно за этим она и внедряется.

Проблема курицы и яйца: если фабрика создает объекты, то кто создаст фабрику? - конечно же другая фабрика фабрик, а эту
фабрику еще одна, мега фабрика. Тут главное помнить об этой проблеме и не увлекаться. В .net я бы предложил создавать
фабрики через DI и не лезть в гигафабрики.
Отдельная разновидности абстрактной фабрики - обощенная фабрика с использованием generic. Довольно проста в реализации и
проще используется, как по мне, такой вариант исполнения абстрактной фабрики, наиболее предпочтильный.

### Фабричный метод (Factory method)

Фабрикой чаще всего называют именно этот паттерн!
Выделяет интерфейс для создания объектов, подклассы сами решают как и какой объект иницианализировать.

Существует несколько вариантов реализации фабричного метода:

* классический
* полиморфный
* статический

Классический фабричный метод привязан к текущему уровню иерархии и не может быть использован в другом контексте. Поэтому
встречается реже всех остальных. (Classic)

Полиморфный фабричный метод позволяет получает контекст создания объекта и решает как именно его создать, отталкиваясь
от переданного ему контекста. Также использовать этот подход можно для сокрытия довольно сложного создания объектов, где
могут быть внешние зависимости и довольно долгий процесс создания объекта. (Strategy)

Статический фабричный метод (MoverWorker) является самым простым вариантом реализации, однако может пригодиться в ряде
случаев:

* Позволяет добавить множество аналогов конструктора с одним и тем же набором аргументов
* Позволяет сделать создание объекта асинхронно
* Скрывает иерархию наследования
* Позволяет вызвать виртуальный метод после создания объекта, точнее сделать статический аналог этого вызова
* Фасад для создания объекта, позволяет вынести сложный процесс создания объекта в отдельный метод
* Кэширование - можно возвращать не только что созданные объекты, а закэшированные (можно сделать это и через singlton
  фабрику, и как мне кажется так будет даже лучше)

### Строитель (Builder)

Паттерн позволяет выстраивать сложные многоуровневые этапы создания объекта, давая пользователю выбор, что должно быть в
этом объекте.

В .net практически не используется стандартная схема строителя, так как она вносит много сложностей и клиент не будет
понимать какой по итогу объект он создал.
Чаще применяется упрощенная версия строителя, где клиент и строитель знают, что за объект они собирают.

Строитель часто в .net. StringBuilder, fixture, mock, у неизменяемых коллекций есть Builder.

Когда использовать:

* При работе с неизменяемыми коллекциями
* Для предоставления возможности разнообразной поэтапной сборки объекта

При создании строителя рекомендую придерживаться fluent interface (поледовательной цепочки вызовов, как напр. LINQ).

Если нужно, чтобы при создании объекта были гарантировано вызваны некоторые команды, то можно воспользоваться паттерном
Состояние.
Через состояние можно переводить строителя от стадии к стадии, тем самым ограничить набор команд, доступный после
очередного этапа строительства объекта.

## Структурные паттерны

### Адаптер (Adapter)

Нужен для оъединения под один интерфейс классы с дургими несовместимыми
интерфейсами. По сути создается интерфейс, который будет использовать
клиент и его реализация, заточенная под использование этих
несовместимых реализаций.

Позволяет объединить, ранее непригодные для использования под одним интерфейсом, классы, при этом не изменяя эти классы.

Когда использовать:

* Для совмещения разных частей программ, совмещения кода, для которого ранее приходилось делать практически тоже самое,
  но немного под другими интерфейсами
* Для мягкого рефакторинга. Для проверки успешности рефакторинга, можно добавить адаптер и посмотреть что получится,
  можно оставить как вышло, тогда не придется залазить в реализацию адаптиремых классов.

### Фасад (Facade)

Объединяет несколько интерфейсов в один интерфейс более высокого уровня. Фасад нужен для УПРОЩЕНИЯ работы с частью
системы.

Когда использовать:

* Когда весь возможный функционал не нужен клиенту и ему достаточно будет выделить несколько операций над системой за
  фасадом
* Когда есть цель скрыть часть функционала за фасадом
* Когда работать с набором классов становится довольно сложно и некоторые классы прусутствуют в нескольких местах и
  используются аналогично

Плюсы паттерна:

* Простота тестирования - при обновлении функционала за фасадом, достаточно проверить работу фасада
* Замена библиотек/компонентов системы за фасадом будет сильно проще проходить, так как изменения будут только в фасаде

### Декоратор (Decorator)

Позволяет динамечески добавлять объекту новую функциональность.

Подобное можно сделать и с использованием наследования, однако жеская связь родителя и наследника может вызвать ряд
проблем при изменении родителя. В декораторе используется агрегация, что позволяет довольно гибко использовать и
настраивать использование дополнительной функциональности.

Использование декоратора дает новую гибкость системе, но и имеет ряд недостатков:

* Повышается сложность системы, разобраться как это работает, не зная идеи паттерна, довольно сложно
* Сложность отладки возрастает, если декорируется сам результат, то понять где ошибка становится еще сложнее
* Если декораторы изменяются динамически в зависимости от всяких факторов, то это еще больше усложнит понимание и
  отладку приложения
* Сложность инициализации декоратора. Возможно придется создавать фабрики или грамоздить довольно запутанную схему
  инициализации в DI
* Чуствительность к порядку создания вложенных декорируемых объектов. От порядка может зависеть конечный результат
  работы методов и побочная функциональность. От чего, место инциализации очень важно при работе с декораторами и может
  нести в себе вероятность появления ошибок

Когда использовать:

* Кеширование результатов
* Замеры времени и нагрузки работы методов
* Дополнительное логирование результатов работы методов
* Управление доступом пользователей
* Модификация результатов работы декорируемых методов

### Компоновщик (Composite)

Позволяет создавать древовидные структуры из объектов для представления "часть - целое". Дает клиенту едиообразный
подхот для для работы с единичными и составными объектами.

Паттерн создавать иерархии объектов и настраивать необходимую логику как тебе нужно.

Создавать компоновщик можно через фабричный метод. Или же добавить методы Add Remove в составной или базовый компонент.
Как по мне, использование фабричного метода (со стратегией) более оптимальна, так как можно не бояться об дальнейшем
изменении этого объекта после его создания.

Когда использовать:

* Для создания гибких фильтров и контекста стратегий
* Для создания декораторов, который фактически является опредленной реализацией этого паттерна
* Для создания объектов данных с неограниченной глубиной (папка в папке с файлами, где папка - составной объект, файл -
  конечный объект)

### Заместитель (Proxy)
Представляет из себя промежуточный слой между двумя системами, которые раньше использовались напрямую (proxy имитирует API использовавшегося сервиса).

Под определение заместителя могут попасть все клиенты к различным сервисам, особенно, если они вынесены из пределы системы.

ORM ферймворки - отличный пример заместителя. Они скрывают в себе логику составления запросов к БД и генерируют оболочку для сущностей.

