Проект с примерами паттернов проектирования

<h3>Стратегия (Strategy)</h3>
Пример стратегии - IFiller и его наследники и StorageService, который, через передаваемый ему контекст и фабричный метод, получает нужного ему наследника и заполняет хранилища нужным образом.

Паттерн позволяет инкапслуровать поведение и подменять его при необходимости.

В данном примере, StorageService не знает как именно выполнялось заполнение хранилищ, он получил нужный объект и вызвал метод, делающий то, что ему нужно.

Еще пример стратегии можно встретить при распределении зависимостей в DI. При конфигурации сервисов можно указать необходимые реализации для конкретных классов, таким образом можно изменять стандартную реализацию или указывать специфическую.

В .NET стратегии применяются повсеместно, так например в LINQ с помощью лямб передаются указания, как именно нужно сравнивать элементы. Можно это сделать реализовав интерфейс IComparer.

<h3>Шаблонный метод (Template method)</h3>
Три различных варианта реализации паттерна Шаблоный метод: классический через абстрактный класс и наследников, через делегаты, через расширения.
DesignPatterns/Application/Strategy.

Паттерн нужен для получения возможности изменения некоторых этапов алгоритма, без изменения структы алгоритма в целом.

Шаблонный метод следует использовать там, где появилась необходимость переиспользовать код с частичными изменениями.

Шаблонный метод можно встретить например в IDisposable.


<h3>Посредник (Mediator)</h3>
Нужен для объединения классов, при этом давая им возможность развиваться независимо.
DesignPatterns/Application/Mediator

StoragePacker - класс, связывающий IGoodsProvider и IStorageProvider.

Не стоит использовать посредника в сильно связанных классах, это может усложнить понимание работы классов и вместо изменений в двух классах, придется вносить изменения во все 3.

Посредники применяются очень часто, важно не усложнять ими дальнейшую разработку а наоборот упрощать дальнейшее развитие систем.

Посредники применяются в взаимодействии между целыми модулями и слоями. Так уровень приложения (application) часто может являться посредником между доменным (domain) и сервисными уровнями (service).


<h3>Итератор (Iterator)</h3>
Паттерн предоставляет доступ ко всем элементам составного объекта (коллекции), не раскрывая его внутреннего содержания (не предоставляя всю коллекцию, только отдельные элементы).
Паттерн нужен для оптимизации работы с коллекциями, ограничения доступа к ним и предаставления ограниченного API для работы с ними.

В .NET есть готовая к использованию реализация этого паттерна IEnumerator и IEnumerable

Для работы с foreach необязательно наследоваться от IEnumerable<T> \ IEnumerator.
Достаточно, чтобы класс коллекции содержал метод GetEnumerator, который будет возвращать тип с методом bool MoveNext() и свойством
Current.

Паттерн итератор можно использовать для создания генераторов. Для генерации значений, а не для обхода внутренней коллекции.

Существует две возможные реализации итераторов: внешние и внутренние. Внешние - обход производится клиентом, путем вызова Next(). Внутренний итератор информирует
клиентов о том, что текущий элемент переключен или вызывает самостоятельно метод, который ему передает клиент при появлении нового (слудующего) эелемента.

IEnumerable \ IEnumerator - пример внешнийх итераторов. GoodsIterator, GoodsCreator
IObserver \ IObservable - пример внутреннего итератора. ObservableGoods и GoodsObserver.

Использовать стоит для оптимизации, если объекты в коллекции будут обрабатываться разово (например для чтения использутся один foreach), то итераторы топ!
Возможны случаи, когда есть есть необходимость оградить существующую коллекцию и предоставлять к ней закрытый доступ.


<h3>Наблюдатель (Observer)</h3>
