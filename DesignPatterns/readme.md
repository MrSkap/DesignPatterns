Проект с примерами паттернов проектирования

<h3>Стратегия (Strategy)</h3>
Пример стратегии - IFiller и его наследники и StorageService, который, через передаваемый ему контекст и фабричный
метод, получает нужного ему наследника и заполняет хранилища нужным образом.

Паттерн позволяет инкапслуровать поведение и подменять его при необходимости.

В данном примере, StorageService не знает как именно выполнялось заполнение хранилищ, он получил нужный объект и вызвал
метод, делающий то, что ему нужно.

Еще пример стратегии можно встретить при распределении зависимостей в DI. При конфигурации сервисов можно указать
необходимые реализации для конкретных классов, таким образом можно изменять стандартную реализацию или указывать
специфическую.

В .NET стратегии применяются повсеместно, так например в LINQ с помощью лямб передаются указания, как именно нужно
сравнивать элементы. Можно это сделать реализовав интерфейс IComparer.

<h3>Шаблонный метод (Template method)</h3>
Три различных варианта реализации паттерна Шаблоный метод: классический через абстрактный класс и наследников, через
делегаты, через расширения.
DesignPatterns/Application/Strategy.

Паттерн нужен для получения возможности изменения некоторых этапов алгоритма, без изменения структы алгоритма в целом.

Шаблонный метод следует использовать там, где появилась необходимость переиспользовать код с частичными изменениями.

Шаблонный метод можно встретить например в IDisposable.

<h3>Посредник (Mediator)</h3>
Нужен для объединения классов, при этом давая им возможность развиваться независимо.
DesignPatterns/Application/Mediator

StoragePacker - класс, связывающий IGoodsProvider и IStorageProvider.

Не стоит использовать посредника в сильно связанных классах, это может усложнить понимание работы классов и вместо
изменений в двух классах, придется вносить изменения во все 3.

Посредники применяются очень часто, важно не усложнять ими дальнейшую разработку а наоборот упрощать дальнейшее развитие
систем.

Посредники применяются в взаимодействии между целыми модулями и слоями. Так уровень приложения (application) часто может
являться посредником между доменным (domain) и сервисными уровнями (service).

<h3>Итератор (Iterator)</h3>
Паттерн предоставляет доступ ко всем элементам составного объекта (коллекции), не раскрывая его внутреннего содержания (
не предоставляя всю коллекцию, только отдельные элементы).
Паттерн нужен для оптимизации работы с коллекциями, ограничения доступа к ним и предаставления ограниченного API для
работы с ними.

В .NET есть готовая к использованию реализация этого паттерна IEnumerator и IEnumerable

Для работы с foreach необязательно наследоваться от IEnumerable<T> \ IEnumerator.
Достаточно, чтобы класс коллекции содержал метод GetEnumerator, который будет возвращать тип с методом bool MoveNext() и
свойством
Current.

Паттерн итератор можно использовать для создания генераторов. Для генерации значений, а не для обхода внутренней
коллекции.

Существует две возможные реализации итераторов: внешние и внутренние. Внешние - обход производится клиентом, путем
вызова Next(). Внутренний итератор информирует
клиентов о том, что текущий элемент переключен или вызывает самостоятельно метод, который ему передает клиент при
появлении нового (слудующего) эелемента.

IEnumerable \ IEnumerator - пример внешнийх итераторов. GoodsIterator, GoodsCreator
IObserver \ IObservable - пример внутреннего итератора. ObservableGoods и GoodsObserver.

Использовать стоит для оптимизации, если объекты в коллекции будут обрабатываться разово (например для чтения
использутся один foreach), то итераторы топ!
Возможны случаи, когда есть есть необходимость оградить существующую коллекцию и предоставлять к ней закрытый доступ.

<h3>Наблюдатель (Observer)</h3>
Наблюдатель позволяет уведомить всех желающих об изменении состояния или событии.

В .net есть несколько способов реализации этого паттерна:

* интерфейсы-наблюдатели (см. классическую диаграму паттерна)
* события
* делегаты
* интерфейсы IObserver/IObservable

#### Когда и что использовать

Реализация через стандартную схему можно использовать при наличии каких-либо внутренних абстракций.
Релизация через делегаты удобна при соотношении 1 к 1. Однако нужно быть увереным, что в дальнейшем получателей не
станет несколько.
Реализация через события удобна в большинстве других случаев, однако нужно внимательно следить за получателями, так как
есть риск утечки памяти при пропаже получателей. Для борьбы с утечками можно использовать слабыми событиями Weak Event
Pattern
Реализация через IObservable может быть чуть более грамоздкой и сложно (по моему мнению), однако несет в себе куда
меньше рисков утечки, позволяет очень гибко настраивать обработку новых сообщений.

Ситуации для применения паттерна:

1. Отслеживание состояния объектов, находящихся вне приложения (файлов, программ)
2. Интервальное появление новых данных (раз в n минут нужно что-то делать)
3. В MVC часто используется данный паттерн для свзывания модели и контроллера
4. В целом позволяет связать разные части приложения воедино

### Посетитель (Visitor)

Паттерн позволяет добавить новую функциональность практически не изменяя классы.

Паттерн следует использовать в ситуациях, когда набор типов стабилен, но операции в этих типах нет.
Функиональный вариант лучше подойдет в небольших иерархичных структурах, затем можно будет вернуться и передалать через
классический вариант реализации данного паттерна.

### Команда (Command)

Паттерн позволяет оборачивать запросы в объекты, вызывать их когда нужно, а также сохранять состояние или составлять
последовательность исполненных команд.
В .net удоблее успользовать реализацию через делегаты, так больше гибкости и возможности переиспользования.

Примером в .net можно назвать Task<T>, объект принимает делегат Funk<T> который может быть вызван в будущем для
получения результата задачи.

Когда можно задуматься об использовании паттерна:

* Необходимо хранить историю вызовов
* Отмена операций
* Очередь запросов
* Отложенный вызов
* Передача команд другим объектам

### Состояние (State)

Позволет изменять объекту изменять свое поведение в зависимости от внутреннего состояния.

Если есть задача полностью ограничить использование некторых методов, состояния могут реализовывать различный набор
интерфейсов и подходить под разные ситуации.

В .net Task изменяет свое состояние в течении создания, выполнения и завершения выполнения задачи.

Не стоит использовать, если этих состояний не много и их логика не так сложна.

Стоит использовать:

* Когда есть потребность в изменении логики работы объекта в зависимости от каких-либо внутренних изменений

